# Solutions
- [Implement a Design Pattern](#implement-a-design-pattern)
- [Leverage Inner Classes for Data Encapsulation](#leverage-inner-classes-for-data-encapsulation)
- [Create a Generic Method for Data Validation](#create-a-generic-method-for-data-validation)

## Implement a Design Pattern
- creating a text formatter for a text editor
- a text editor can have different text formatters
- so we will have a bunch of text formatters and pass the required one

  - to the text editor in order to formate a text

- Using the `Strategy Design Pattern`

  - A family of algorithms encapsulating one another
  - Keep the implementations of each of the algorithms in a separate class (Strategy)
  - any object using the strategy object - called - context object
  - strategy objects must be designed to offer the same interface
  - what a client needs to do is to configure the context, with the selected strategy instance
  - what do we have
    - `Strategy`:
      - declares the interface common to all supported algorithms
      - note that `context` will use this interface to call the algorithm defined by the `concrete strategy`
    - `Concrete Strategy`:
      - implements the algorithm using the `strategy` interface
    - `Context`:
      - congfigured with a `concrete strategy` object
      - maintains a reference to the `strategy` object
      - may define an interface that lets `strategy` access its data

- [Solution - ./src/main/java/frank/oop_deep_dive/labone](./src/main/java/frank/oop_deep_dive/labone)
    - `CapTextFormatter`, is a concrete text formatter that implements the TextFormatter interface and the class is used to change the text into capital case
    - The `LowerTextFormatter` is a concrete text formatter that implements the TextFormatter interface and the class is
used to change the text into small case.
    - `TextEditor` class holds a reference to the `TextFormatter` interface

- Advantages
    -  We can add new text formatters without disturbing the current code



## Leverage Inner Classes for Data Encapsulation
- Outer Class: `Rocket` ðŸš€
- Attributes:
    - `name`: The name of the rocket.
    - `weight`: The weight of the rocket (in kilograms).
- Methods:
    - `toString()`: Returns a string representation of the rocket.
    - `displayRocketDetails()`: Prints the rocket's details to the console.
- Inner Class: `Engine`
    - Attributes:
        - `type`: The engine type (e.g., liquid, solid).
        - `thrust`: The thrust generated by the engine (in Newtons).
    - Methods:
        - `calculateThrustToWeightRatio()`: Calculates and returns the thrust-to-weight ratio for the rocket.
        - `displayEngineDetails()`: Prints the engine's details, including the thrust-to-weight ratio.

The inner class Engine provides functionality closely tied to the outer class Rocket, such as calculating the thrust-to-weight ratio using the rocket's weight.

- [Solutions - ./src/main/java/frank/oop_deep_dive/labtwo](./src/main/java/frank/oop_deep_dive/labtwo)



## Create a Generic Method for Data Validation
-  what i did was a Baking Validation Utility
- Generic Validation: Supports validation for different types of data (Integer, String, Double, etc.).
- Modularity: I placed each validation logic in a separate class, improving code clarity.
- Extensibility: New validation criteria can be added easily by implementing the `BakingValidator<T>` interface.
- Structure
    - Interface
        - `BakingValidator<T>`: A generic interface for defining validation criteria.
    - Validators
        - `TemperatureValidator`: Validates if a temperature is within the baking range (150â€“250Â°C).
        - `IngredientNameValidator`: Validates that ingredient names are non-empty and not too long (max 30 characters).
    - `WeightValidator`: Validates if an ingredient's weight is within 0â€“1000 grams.

- [Solution - ./src/main/java/frank/generics_in_depth/lab3](./src/main/java/frank/generics_in_depth/lab3)


























